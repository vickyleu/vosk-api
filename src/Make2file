# 编译配置
# --------------------------------------------------
KALDI_ROOT ?= $(HOME)/travis/kaldi
OPENFST_ROOT ?= $(KALDI_ROOT)/tools/openfst
OPENBLAS_ROOT ?= $(KALDI_ROOT)/tools/OpenBLAS/install
MKL_ROOT ?= /opt/intel/mkl
CUDA_ROOT ?= /usr/local/cuda

# 构建选项
# --------------------------------------------------
USE_SHARED ?= 0             # 使用静态库(0)或动态库(1)
HAVE_OPENBLAS_CLAPACK ?= 1  # 使用OpenBLAS
HAVE_MKL ?= 0               # 使用Intel MKL
HAVE_ACCELERATE ?= 0        # macOS Accelerate框架
HAVE_CUDA ?= 0              # CUDA支持
BUILD_TYPE ?= Release       # 构建类型(Release/Debug)

# 编译器配置
# --------------------------------------------------
CXX ?= g++
AR ?= ar
STRIP ?= strip
EXT ?= so
OUTDIR ?= build

# 源文件配置
# --------------------------------------------------
VOSK_SOURCES := \
  recognizer.cc \
  language_model.cc \
  model.cc \
  spk_model.cc \
  vosk_api.cc \
  postprocessor.cc

VOSK_HEADERS := $(wildcard *.h)

# 条件编译配置
# --------------------------------------------------
ifeq ($(HAVE_CUDA),1)
  VOSK_SOURCES += batch_recognizer.cc batch_model.cc
  VOSK_HEADERS += batch_recognizer.h batch_model.h
endif

# 编译器标志
# --------------------------------------------------
CFLAGS := -std=c++17 -fPIC -DFST_NO_DYNAMIC_LINKING -Wno-deprecated-declarations
CFLAGS += -I. -I$(KALDI_ROOT)/src -I$(OPENFST_ROOT)/include

# 优化选项
ifeq ($(BUILD_TYPE),Release)
#  CFLAGS += -Os  -DNDEBUG -ffunction-sections -fdata-sections
  CFLAGS += -O3 -DNDEBUG -ffunction-sections -fdata-sections
else
  CFLAGS += -g -O0
endif

# 数学库配置
# --------------------------------------------------
ifeq ($(HAVE_OPENBLAS_CLAPACK),1)
  CFLAGS += -I$(OPENBLAS_ROOT)/include
  # LDFLAGS += -L$(OPENBLAS_ROOT)/lib -lopenblas -llapack -lblas -lf2c
endif

ifeq ($(HAVE_MKL),1)
  CFLAGS += -DHAVE_MKL=1 -I$(MKL_ROOT)/include
  LDFLAGS += -L$(MKL_ROOT)/lib/intel64 -lmkl_rt
endif

# CUDA配置
# --------------------------------------------------
ifeq ($(HAVE_CUDA),1)
  CFLAGS += -DHAVE_CUDA=1 -I$(CUDA_ROOT)/include
  LDFLAGS += -L$(CUDA_ROOT)/lib64 -lcublas -lcudart
endif

# 依赖库配置
# --------------------------------------------------
KALDI_LIBS := \
  nnet2 online2 decoder ivector  gmm tree feat lat lm rnnlm hmm \
  nnet3 transform cudamatrix matrix fstext util base

ifeq ($(HAVE_CUDA),1)
  KALDI_LIBS += cudadecoder cudafeat
endif

STATIC_LIBS :=


ifeq ($(HAVE_OPENBLAS_CLAPACK),1)
  STATIC_LIBS +=  $(OPENBLAS_ROOT)/lib/libopenblas.a \
   $(OPENBLAS_ROOT)/lib/liblapack.a \
   $(OPENBLAS_ROOT)/lib/libblas.a   \
   $(OPENBLAS_ROOT)/lib/libf2c.a
endif

# 静态库路径
STATIC_LIBS +=  \
  $(foreach lib,$(KALDI_LIBS),$(KALDI_ROOT)/src/$(lib)/kaldi-$(lib).a) \
  $(OPENFST_ROOT)/lib/libfst.a \
  $(OPENFST_ROOT)/lib/libfstngram.a




# 链接选项
# --------------------------------------------------
LDFLAGS += -Wl,--as-needed -latomic -lpthread -ldl

ifeq ($(USE_SHARED),1)
  LDFLAGS += -L$(KALDI_ROOT)/libs -lkaldi-$(subst $(space), -lkaldi-,$(KALDI_LIBS))
else
  LIBS += $(STATIC_LIBS)
endif

# 构建规则
# --------------------------------------------------
VOSK_OBJS := $(addprefix $(OUTDIR)/, $(VOSK_SOURCES:.cc=.o))
TARGET := $(OUTDIR)/libvosk.$(EXT)
SYMB_FILE = "$(OUTDIR)/symbol_defs.txt"
UNDEF_FILE = "$(OUTDIR)/undefined_symbols.txt"
DUP_FILE = "$(OUTDIR)/duplicate_symbols.txt"
NEW_LIB = "$("libvosk%.$(EXT)")_clean.$(EXT)"

.PHONY: all clean diagnose

all: $(TARGET)

$(TARGET): $(VOSK_OBJS) | check_deps
	@echo "\n=> 合并对象文件到: $@"
	@mkdir -p $(OUTDIR)/tmp

	# 解压所有静态库
    # 只解压需要的库，可以创建一个精简的库列表
	@echo "=> 解压必要的库..."
	@mkdir "$(OUTDIR)/libs"
	@$(foreach lib,$(LIBS), \
      $(if $(wildcard $(lib)), \
        (cd $(OUTDIR)/tmp && cp $(lib) ../libs && \
        mkdir "$(basename $(notdir $(lib)))" &&  \
        cd "$(basename $(notdir $(lib)))" && \
        $(AR) x "../../libs/$(notdir $(lib))" );, \
        $(error Missing essential library: $(lib))))

    # 符号优化：移除未使用的符号
	@echo "=> 移除未使用符号..."
#	@find $(OUTDIR)/tmp -name '*.o' -exec $(OBJCOPY) --strip-debug {} \;
	@find $(OUTDIR)/tmp/libf2c -name '*.o' -exec $(OBJCOPY) --strip-symbol=main  {} \;
	@find $(OUTDIR)/tmp/libopenblas -name '*.o' -exec $(OBJCOPY) --strip-symbol=lsame_ \
				--strip-symbol=c_abs \
				--strip-symbol=dcabs1_ \
				--strip-symbol=scabs1_ \
				--strip-symbol=z_abs \
  		{} \;

	@echo "=> 将所有处理好的.o文件移动到$(OUTDIR)/tmp"
	@find $(OUTDIR)/tmp -name '*.o' -exec mv {} $(OUTDIR)/tmp \;

#	@echo "=> 处理重复符号..."
#	@find $(OUTDIR)/tmp -name '*.o' | while read file; do \
#	  mv "$$file" "$(OUTDIR)/tmp/$$(md5sum "$$file" | cut -d' ' -f1).o"; \
#	done

#	@echo "=> 自动剥离重复符号..."
#	dup_syms=$(nm -g --defined-only $(find build/tmp -name '*.o') | awk '{print $$3}' | sort | uniq -d); \
#    for sym in $$dup_syms; do \
#      if [ "$$sym" != "Konan_main" ] && ! echo "$$sym" | grep -q '^_ZGVZ'; then \
#        find build/tmp -name '*.o' -exec $(OBJCOPY) --strip-symbol=$$sym {} \; || true; \
#      fi; \
#    done

    # 合并对象文件
	@echo "=> 创建最终库"
	$(AR) -rcs $@.tmp $(VOSK_OBJS) $(OUTDIR)/tmp/*.o

    # 链接时优化（Release模式）
ifeq ($(BUILD_TYPE),Release)
	@echo "=> 深度优化库大小"
    # 移除所有调试信息
#	$(STRIP) --strip-unneeded $@.tmp
	$(STRIP) --strip-debug $@.tmp
	# 移除未使用的段和符号
#	$(OBJCOPY) --discard-all $@.tmp $@
	# 可选：使用UPX进一步压缩（如果适用）
	upx --best $@ || echo "UPX未安装或不适用, 跳过压缩步骤"
else
	mv $@.tmp $@
endif

#	@rm -f $(OUTDIR)/tmp/* $(OUTDIR)/*.o
#	@echo "=> 正在解压 $(TARGET) ..."
#	@cd $(OUTDIR)/tmp && $(AR) x "$(abspath $(TARGET))" || echo "解压失败"
#	@cd ..
#
#    # 收集所有目标文件中定义的符号：收集T类型(已定义)和U类型(未定义).
#	@echo "=> 收集符号定义到: $(SYMB_FILE) 和 $(UNDEF_FILE)"
#	@rm -f "$(SYMB_FILE)" "$(UNDEF_FILE)"
#	@echo "=> 收集符号定义..."
#	@for f in $(OUTDIR)/tmp/*.o; do \
#        nm "$$f" | awk '/ T / { print $$3 " T " FILENAME }' >> "$(SYMB_FILE)"; \
#        nm "$$f" | awk '/ U / { print $$2 " U " FILENAME }' >> "$(UNDEF_FILE)"; \
#    done
#
#	@echo "=> 检查未定义符号是否有对应定义..."


#    # 在脚本开头
#	@echo "=> 创建系统符号排除列表..."
#	@echo "=> 创建系统符号排除列表..."
#	@rm -rf "$(OUTDIR)/system_symbols_exclude.txt" "$(OUTDIR)/temp_symbols.txt"
#	@(echo "getenv"; \
#	  echo "strtol"; \
#	  echo "memcpy"; \
#	  echo "memmove"; \
#	  echo "memcmp"; \
#	  echo "exit"; \
#	  echo "floorf"; \
#	  echo "times"; \
#	  echo "fprintf"; \
#	  echo "fwrite"; \
#	  echo "stderr"; \
#	  echo "__errno_location"; \
#	  echo "__aeabi_ldivmod"; \
#	  echo "popen"; \
#	  echo "free"; \
#	  echo "malloc"; \
#	  echo "log1p"; \
#	  echo "exp"; \
#	  echo "strchr"; \
#	  echo "strerror"; \
#	  echo "strlen"; \
#	  echo "fseeko64"; \
#	  echo "ftello64"; \
#	  echo "acos"; \
#	  echo "log"; \
#	  echo "sqrt") > "$(OUTDIR)/temp_symbols.txt"
#
#	# 添加所有以特定前缀开头的符号
#	grep -E '_Z(N|S|T)' "$(UNDEF_FILE)" | awk '{print $2}' >> "$(OUTDIR)/temp_symbols.txt"
#	grep -E '^f__' "$(UNDEF_FILE)" | awk '{print $2}' >> "$(OUTDIR)/temp_symbols.txt"
#	grep -E '^__cxa' "$(UNDEF_FILE)" | awk '{print $2}' >> "$(OUTDIR)/temp_symbols.txt"
#	grep -E '^__atomic' "$(UNDEF_FILE)" | awk '{print $2}' >> "$(OUTDIR)/temp_symbols.txt"
#	grep -E '^__aeabi' "$(UNDEF_FILE)" | awk '{print $2}' >> "$(OUTDIR)/temp_symbols.txt"
#	grep -E '^__sync' "$(UNDEF_FILE)" | awk '{print $2}' >> "$(OUTDIR)/temp_symbols.txt"
#	grep -E '^__gxx' "$(UNDEF_FILE)" | awk '{print $2}' >> "$(OUTDIR)/temp_symbols.txt"
#	grep -E '^__dynamic' "$(UNDEF_FILE)" | awk '{print $2}' >> "$(OUTDIR)/temp_symbols.txt"
#	grep -E '^__assert' "$(UNDEF_FILE)" | awk '{print $2}' >> "$(OUTDIR)/temp_symbols.txt"
#	grep -E '^__dso' "$(UNDEF_FILE)" | awk '{print $2}' >> "$(OUTDIR)/temp_symbols.txt"
#	grep -E '^FLAGS_' "$(UNDEF_FILE)" | awk '{print $2}' >> "$(OUTDIR)/temp_symbols.txt"
#	grep -E '^_GLOBAL_' "$(UNDEF_FILE)" | awk '{print $2}' >> "$(OUTDIR)/temp_symbols.txt"
#
#
#
#    # 使用sort -u删除重复项并创建最终的排除列表
#	@sort -u "$(OUTDIR)/temp_symbols.txt" > "$(OUTDIR)/system_symbols_exclude.txt"
#	@rm -f "$(OUTDIR)/temp_symbols.txt"

#	@MISSING_SYMBOLS=() && \
#	while read -r uline; do \
#        usym=$$(echo "$$uline" | awk '{print $$1}'); \
#        ufile=$$(echo "$$uline" | awk '{print $$3}'); \
#        if ! grep -q "^$$usym T " "$(SYMB_FILE)" && \
#           ! grep -q "^$$usym$$" "$(OUTDIR)/system_symbols_exclude.txt"; then \
#            echo "警告: 符号 $$usym 在 $$ufile 中被引用但未在任何目标文件中定义"; \
#            MISSING_SYMBOLS+=("$$usym"); \
#        fi; \
#	done < "$(UNDEF_FILE)" && \
#	echo "=> 检查未定义符号..." && \
#	if [ "$${#MISSING_SYMBOLS[@]}" -gt 0 ]; then \
#	    echo "注意：发现 $${#MISSING_SYMBOLS[@]} 个未定义符号。这些可能需要从外部库获取。"; \
#	else \
#	    echo "所有未定义符号都在库中有定义，链接应该没有问题。"; \
#	fi


#	# 统计重复定义的符号，并列出对应的目标文件列表
#	@rm -f "$(DUP_FILE)"
#	@awk '$$2 == "T" { sym[$$1] = (sym[$$1] ? sym[$$1] " " $$3 : $$3); count[$$1]++ } END { for (s in count) { if(count[s] > 1) { print s, sym[s] } } }' "$(SYMB_FILE)" > "$(DUP_FILE)"
#	@echo "=> 以下符号重复定义,将保留第一个定义,其它的剥除:"
#	@cat "$(DUP_FILE)"
#	@echo "=> 对于每个重复符号,保留第一个定义,其它的剥除..."
#	@while read -r line; do \
#        sym=$$(echo "$$line" | awk '{print $$1}'); \
#        all_files=$$(echo "$$line" | cut -d' ' -f2-); \
#        set -- $$all_files; \
#        keep="$$1"; \
#        shift; \
#        for file in "$$@"; do \
#            echo "剥离符号 $$sym 从 $$file (保留 $$keep)"; \
#            $(PREFIX)-objcopy --strip-symbol="$$sym" "$$file" || echo "剥离 $$sym 失败于 $$file"; \
#        done; \
#    done < "$(DUP_FILE)"
#
#	@echo "=> 重新打包生成新的静态库: ../$(NEW_LIB)"
#	@cd $(OUTDIR)/tmp && $(AR) rcs ../$(NEW_LIB) *.o
#	@cd $(CURDIR)
#	@echo "当前目录是: $$(pwd)"
#	@rm -f $@
#	@mv "$(OUTDIR)/$(NEW_LIB)" $@
#	@rm -rf $(OUTDIR)/tmp $(OUTDIR)/*.txt

	@mv $@.tmp $@
	@echo "处理完成. 请检查新库是否满足预期."
	@echo "构建成功! 输出文件: $@"
	@echo "优化后大小: $$(du -h $@ | cut -f1)"

# 编译时启用更高级的优化
$(OUTDIR)/%.o: %.cc $(VOSK_HEADERS)
	@mkdir -p $(@D)
	@echo "编译: $< => $@"
	$(CXX) $(CFLAGS) -c -o $@ $<


check:
	@MISSING_SYMBOLS=() && \
    symbols_len="$${#MISSING_SYMBOLS[@]}" && \
    echo "数组长度: $$symbols_len" && \
    if [ "$${#MISSING_SYMBOLS[@]}" -gt 0 ]; then \
        echo "条件成立"; \
    fi

#    # 收集所有目标文件中定义的符号：收集T类型(已定义)和U类型(未定义).
#	@echo "=> 收集符号定义到: $(SYMB_FILE) 和 $(UNDEF_FILE)"
#	@rm -f "$(SYMB_FILE)" "$(UNDEF_FILE)"
#	@echo "=> 收集符号定义..."
#	@for f in $(OUTDIR)/tmp/*.o; do \
#        nm "$$f" | awk '/ T / { print $$3 " T " FILENAME }' >> "$(SYMB_FILE)"; \
#        nm "$$f" | awk '/ U / { print $$2 " U " FILENAME }' >> "$(UNDEF_FILE)"; \
#    done

	# 在脚本开头
	@echo "=> 创建系统符号排除列表..."
	@rm -rf "$(OUTDIR)/system_symbols_exclude.txt" "$(OUTDIR)/temp_symbols.txt"
	@(echo "getenv"; \
	  echo "strtol"; \
	  echo "memcpy"; \
	  echo "memmove"; \
	  echo "memcmp"; \
	  echo "exit"; \
	  echo "floorf"; \
	  echo "times"; \
	  echo "fprintf"; \
	  echo "fwrite"; \
	  echo "stderr"; \
	  echo "__errno_location"; \
	  echo "__aeabi_ldivmod"; \
	  echo "popen"; \
	  echo "free"; \
	  echo "malloc"; \
	  echo "log1p"; \
	  echo "exp"; \
	  echo "strchr"; \
	  echo "strerror"; \
	  echo "strlen"; \
	  echo "fseeko64"; \
	  echo "ftello64"; \
	  echo "acos"; \
	  echo "log"; \
	  echo "sqrt") > "$(OUTDIR)/temp_symbols.txt"
	cat "$(UNDEF_FILE)" | awk '{gsub(/ U$/, "", $1); print $1}' | head -n 5
#	# 添加所有以特定前缀开头的符号
#	grep -E '_Z(N|S|T)' "$(UNDEF_FILE)" | awk '{print $1}' >> "$(OUTDIR)/temp_symbols.txt"
#	grep -E '^f__' "$(UNDEF_FILE)" | awk '{print $1}' >> "$(OUTDIR)/temp_symbols.txt"
#	grep -E '^__cxa' "$(UNDEF_FILE)" | awk '{print $1}' >> "$(OUTDIR)/temp_symbols.txt"
#	grep -E '^__atomic' "$(UNDEF_FILE)" | awk '{print $1}' >> "$(OUTDIR)/temp_symbols.txt"
#	grep -E '^__aeabi' "$(UNDEF_FILE)" | awk '{print $1}' >> "$(OUTDIR)/temp_symbols.txt"
#	grep -E '^__sync' "$(UNDEF_FILE)" | awk '{print $1}' >> "$(OUTDIR)/temp_symbols.txt"
#	grep -E '^__gxx' "$(UNDEF_FILE)" | awk '{print $1}' >> "$(OUTDIR)/temp_symbols.txt"
#	grep -E '^__dynamic' "$(UNDEF_FILE)" | awk '{print $1}' >> "$(OUTDIR)/temp_symbols.txt"
#	grep -E '^__assert' "$(UNDEF_FILE)" | awk '{print $1}' >> "$(OUTDIR)/temp_symbols.txt"
#	grep -E '^__dso' "$(UNDEF_FILE)" | awk '{print $1}' >> "$(OUTDIR)/temp_symbols.txt"
#	grep -E '^FLAGS_' "$(UNDEF_FILE)" | awk '{print $1}' >> "$(OUTDIR)/temp_symbols.txt"
#	grep -E '^_GLOBAL_' "$(UNDEF_FILE)" | awk '{print $1}' >> "$(OUTDIR)/temp_symbols.txt"
#
#    # 使用sort -u删除重复项并创建最终的排除列表
#	@sort -u "$(OUTDIR)/temp_symbols.txt" > "$(OUTDIR)/system_symbols_exclude.txt"
#	@rm -f "$(OUTDIR)/temp_symbols.txt"
#
#	@MISSING_SYMBOLS=() && \
#	while read -r uline; do \
#		usym=$$(echo "$$uline" | awk '{print $1}'); \
#		ufile=$$(echo "$$uline" | awk '{print $3}'); \
#		ufile=$${ufile:-"unknown"}; \
#		if ! grep -q "^$$usym T " "$(SYMB_FILE)" && \
#			! grep -q "^$$usym$$" "$(OUTDIR)/system_symbols_exclude.txt"; then \
#			echo "警告: 符号 $$usym 在 $$ufile 中被引用但未在任何目标文件中定义"; \
#			MISSING_SYMBOLS+=("$$usym"); \
#		fi; \
#    done < "$(UNDEF_FILE)" && \
#	echo "=> 检查未定义符号..." && \
#	if [ "$${#MISSING_SYMBOLS[@]}" -gt 0 ]; then \
#	    echo "注意：发现 $${#MISSING_SYMBOLS[@]} 个未定义符号。这些可能需要从外部库获取。"; \
#	else \
#	    echo "所有未定义符号都在库中有定义，链接应该没有问题。"; \
#	fi

check_deps:
	@echo "=> 检查依赖项..."
	$(foreach lib,$(STATIC_LIBS), \
	  $(if $(wildcard $(lib)),, \
	    $(error 缺少依赖库: $(lib))))
	@echo "所有依赖库存在"

diagnose:
	@echo "\n=== 诊断信息 ==="
	@echo "Kaldi版本: $(shell grep 'KALDI_VERSION' $(KALDI_ROOT)/src/base/version.h)"
	@echo "OpenFST版本: $(shell $(OPENFST_ROOT)/bin/fstversion 2>/dev/null || echo '未知')"
	@echo "关键符号检查:"
	@nm $(KALDI_ROOT)/src/chain/kaldi-chain.a | grep -q ComputeChainObjfAndDeriv || echo "错误：缺少chain符号"
	@echo "原子操作支持:"
	$(CXX) -x c++ - <<<"int main(){long *p; __atomic_load_8(p,0);}" -latomic -o /dev/null 2>/dev/null \
	  && echo "√ 支持64位原子操作" || echo "× 缺少原子操作支持"

clean:
	rm -rf $(OUTDIR)
	rm -f *.o *.so *.a